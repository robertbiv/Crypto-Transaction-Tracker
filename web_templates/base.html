<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Crypto Tax Generator{% endblock %}</title>
    
    <!-- Material Design 3 -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-success: #2E7D32;
            --md-sys-color-on-success: #FFFFFF;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Navigation Bar */
        .nav-bar {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .nav-bar h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }
        
        .nav-menu {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .nav-link {
            color: var(--md-sys-color-on-primary);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .nav-link.active {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Cards */
        .card {
            background: var(--md-sys-color-surface);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .card-title {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--md-sys-color-on-surface);
        }
        
        /* Buttons */
        .btn {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }
        
        .btn-primary:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .btn-secondary {
            background: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
        }

        .btn-success {
            background: var(--md-sys-color-success);
            color: var(--md-sys-color-on-success);
        }
        
        .btn-success:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            filter: brightness(1.1);
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }
        
        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid var(--md-sys-color-surface-variant);
        }
        
        th {
            font-weight: 500;
            color: var(--md-sys-color-on-surface-variant);
        }
        
        tr:hover {
            background: rgba(103, 80, 164, 0.04);
        }
        
        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--md-sys-color-on-surface-variant);
        }
        
        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--md-sys-color-surface-variant);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
        }
        
        /* Alerts */
        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .alert-success {
            background: #E8F5E9;
            color: #1B5E20;
        }
        
        .alert-error {
            background: #FFEBEE;
            color: #B71C1C;
        }
        
        .alert-warning {
            background: #FFF3E0;
            color: #E65100;
        }
        
        .alert-info {
            background: #E3F2FD;
            color: #0D47A1;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .nav-menu {
                flex-direction: column;
                gap: 4px;
            }
            
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 16px;
            }
            
            table {
                font-size: 12px;
            }
            
            th, td {
                padding: 8px;
            }
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--md-sys-color-primary-container);
            border-top: 5px solid var(--md-sys-color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-content {
            text-align: center;
            max-width: 400px;
            padding: 20px;
        }
        
        .error-icon {
            font-size: 64px;
            color: var(--md-sys-color-error);
            margin-bottom: 16px;
        }
        
        .progress-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .progress-content {
            background: white;
            padding: 32px;
            border-radius: 12px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        
        .progress-title {
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--md-sys-color-on-surface);
        }
        
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--md-sys-color-surface-variant);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--md-sys-color-primary), var(--md-sys-color-tertiary));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .progress-message {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        
        .progress-percentage {
            color: var(--md-sys-color-primary);
            font-weight: 500;
            font-size: 1.1rem;
        }
    </style>
    
    {% block extra_css %}{% endblock %}
</head>
<body>
    {% set hidden_endpoints = ['first_time_setup', 'setup_wizard', 'login'] %}
    {% set show_nav = (session.username and request.endpoint not in hidden_endpoints and not hide_nav) %}
    {% if show_nav %}
    <nav class="nav-bar">
        <h1>ðŸ’° Crypto Tax Generator</h1>
        <div class="nav-menu">
            <a href="/dashboard" class="nav-link">Dashboard</a>
            <a href="/transactions" class="nav-link">Transactions</a>
            <a href="/analytics" class="nav-link">ðŸ§  Analytics</a>
            <a href="/warnings" class="nav-link">Warnings</a>
            <a href="/reports" class="nav-link">Reports</a>
            <a href="/config" class="nav-link">Config</a>
            <a href="/logs" class="nav-link">Logs</a>
            <a href="/schedule" class="nav-link">Schedule</a>
            <a href="/settings" class="nav-link">Settings</a>
            <a href="/logout" class="nav-link">Logout</a>
        </div>
    </nav>
    {% endif %}
    
    <div class="container">
        {% block content %}{% endblock %}
    </div>
    
    <!-- Loading/Error Overlay -->
    <div id="loading-overlay">
        <div id="loading-spinner" class="spinner"></div>
        <div id="loading-message" style="font-size: 1.2rem; font-weight: 500; color: var(--md-sys-color-primary);">Connecting to server...</div>
        
        <div id="error-content" class="error-content" style="display: none;">
            <span class="material-icons error-icon">cloud_off</span>
            <h2 style="margin-bottom: 8px; color: var(--md-sys-color-on-surface);">Connection Failed</h2>
            <p style="margin-bottom: 24px; color: var(--md-sys-color-on-surface-variant);">Unable to reach the server or database. Please check if the application is running.</p>
            <button class="btn btn-primary" id="retryConnectionBtn">
                <span class="material-icons" style="vertical-align: middle; font-size: 18px; margin-right: 8px;">refresh</span>
                Retry Connection
            </button>
        </div>
    </div>
    
    <!-- Progress Modal -->
    <div id="progress-modal" class="progress-modal">
        <div class="progress-content">
            <h3 class="progress-title" id="progress-title">Processing...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="progress-message" id="progress-message">Initializing...</div>
            <div class="progress-percentage" id="progress-percentage">0%</div>
        </div>
    </div>
    
    <script nonce="{{ csp_nonce }}">
        document.addEventListener('DOMContentLoaded', () => {
            const retryBtn = document.getElementById('retryConnectionBtn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => window.location.reload());
            }
        });

        // Secure API client with encryption and CSRF protection
        class SecureAPIClient {
            constructor() {
                this.csrfToken = null;
                this.loadingTimeout = null;
                this.activeRequests = 0;
            }
            
            showLoading() {
                this.activeRequests++;
                
                // Only show if request takes longer than 500ms and no loading is currently scheduled/shown
                if (this.activeRequests === 1 && !this.loadingTimeout) {
                    this.loadingTimeout = setTimeout(() => {
                        const overlay = document.getElementById('loading-overlay');
                        const spinner = document.getElementById('loading-spinner');
                        const message = document.getElementById('loading-message');
                        const error = document.getElementById('error-content');
                        
                        if (overlay && spinner && message && error) {
                            // Don't show if we're already showing an error
                            if (error.style.display === 'block') return;
                            
                            overlay.style.display = 'flex';
                            spinner.style.display = 'block';
                            message.style.display = 'block';
                            error.style.display = 'none';
                        }
                    }, 500);
                }
            }

            hideLoading() {
                this.activeRequests--;
                if (this.activeRequests < 0) this.activeRequests = 0;

                if (this.activeRequests === 0) {
                    if (this.loadingTimeout) {
                        clearTimeout(this.loadingTimeout);
                        this.loadingTimeout = null;
                    }
                    const overlay = document.getElementById('loading-overlay');
                    // Only hide if we are not showing an error
                    if (overlay && overlay.style.display === 'flex' && document.getElementById('error-content').style.display === 'none') {
                        overlay.style.display = 'none';
                    }
                }
            }

            showError() {
                if (this.loadingTimeout) {
                    clearTimeout(this.loadingTimeout);
                    this.loadingTimeout = null;
                }
                const overlay = document.getElementById('loading-overlay');
                const spinner = document.getElementById('loading-spinner');
                const message = document.getElementById('loading-message');
                const error = document.getElementById('error-content');
                
                if (overlay && spinner && message && error) {
                    overlay.style.display = 'flex';
                    spinner.style.display = 'none';
                    message.style.display = 'none';
                    error.style.display = 'block';
                }
            }
            
            async initCSRF() {
                if (!this.csrfToken) {
                    try {
                        const response = await fetch('/api/csrf-token');
                        if (!response.ok) throw new Error('Failed to get CSRF token');
                        const data = await response.json();
                        this.csrfToken = data.csrf_token;
                    } catch (e) {
                        console.error('CSRF Init Error:', e);
                        this.showError();
                        throw e;
                    }
                }
                return this.csrfToken;
            }
            
            generateSignature(data, timestamp) {
                // Signature generation handled server-side
                // This is a placeholder for client-side reference
                return '';
            }
            
            async request(url, options = {}) {
                this.showLoading();
                
                try {
                    await this.initCSRF();
                    
                    const timestamp = new Date().toISOString();
                    const headers = {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': this.csrfToken,
                        ...options.headers
                    };
                    
                    // For write operations, add timestamp and signature
                    if (['POST', 'PUT', 'DELETE'].includes(options.method)) {
                        headers['X-Request-Timestamp'] = timestamp;
                        
                        // Generate signature (simplified for client)
                        let data = {};
                        if (options.body) {
                            try {
                                data = typeof options.body === 'string' ? JSON.parse(options.body) : options.body;
                            } catch (e) {
                                data = {};
                            }
                        }
                        const message = JSON.stringify(data) + timestamp;
                        
                        // Use SubtleCrypto API for HMAC
                        const encoder = new TextEncoder();
                        const key = await window.crypto.subtle.importKey(
                            'raw',
                            encoder.encode(this.csrfToken),
                            { name: 'HMAC', hash: 'SHA-256' },
                            false,
                            ['sign']
                        );
                        const signature = await window.crypto.subtle.sign(
                            'HMAC',
                            key,
                            encoder.encode(message)
                        );
                        const signatureHex = Array.from(new Uint8Array(signature))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                        
                        headers['X-Request-Signature'] = signatureHex;
                    }
                    
                    const response = await fetch(url, {
                        ...options,
                        headers,
                        credentials: 'same-origin'
                    });
                    
                    this.hideLoading();

                    if (!response.ok) {
                        // If server error (500+), show connection error screen
                        if (response.status >= 500) {
                            this.showError();
                            throw new Error('Server Error');
                        }
                        const error = await response.json();
                        throw new Error(error.error || 'Request failed');
                    }
                    
                    return response.json();
                } catch (error) {
                    // If network error (fetch failed), show connection error screen
                    if (error.name === 'TypeError' || error.message === 'Failed to fetch' || error.message === 'Server Error') {
                        this.showError();
                    } else {
                        this.hideLoading();
                    }
                    throw error;
                }
            }
            
            async get(url) {
                return this.request(url, { method: 'GET' });
            }
            
            async post(url, data) {
                // Encrypt sensitive data before sending
                const encryptedData = { data: JSON.stringify(data) };
                return this.request(url, {
                    method: 'POST',
                    body: JSON.stringify(encryptedData)
                });
            }
            
            async put(url, data) {
                // Encrypt sensitive data before sending
                const encryptedData = { data: JSON.stringify(data) };
                return this.request(url, {
                    method: 'PUT',
                    body: JSON.stringify(encryptedData)
                });
            }
            
            async delete(url) {
                return this.request(url, { method: 'DELETE' });
            }
        }
        
        // Global API client instance
        const api = new SecureAPIClient();
        
        // Helper to show alerts with dismiss button
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.style.display = 'flex';
            alertDiv.style.justifyContent = 'space-between';
            alertDiv.style.alignItems = 'center';
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            alertDiv.appendChild(messageSpan);
            
            const dismissBtn = document.createElement('button');
            dismissBtn.textContent = 'Ã—';
            dismissBtn.className = 'alert-dismiss';
            dismissBtn.style.cssText = 'background: none; border: none; font-size: 24px; cursor: pointer; padding: 0 8px; margin-left: 16px;';
            dismissBtn.onclick = function() {
                alertDiv.remove();
            };
            alertDiv.appendChild(dismissBtn);
            
            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(alertDiv, container.firstChild);
            }
        }
        
        // Progress tracking
        class ProgressTracker {
            constructor() {
                this.modal = document.getElementById('progress-modal');
                this.title = document.getElementById('progress-title');
                this.bar = document.getElementById('progress-bar');
                this.message = document.getElementById('progress-message');
                this.percentage = document.getElementById('progress-percentage');
                this.pollInterval = null;
                this.taskId = null;
            }
            
            show(title = 'Processing...') {
                this.title.textContent = title;
                this.updateProgress(0, 'Initializing...');
                this.modal.style.display = 'flex';
            }
            
            hide() {
                this.modal.style.display = 'none';
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
                this.taskId = null;
            }
            
            updateProgress(progress, message = '') {
                this.bar.style.width = progress + '%';
                this.percentage.textContent = Math.round(progress) + '%';
                if (message) {
                    this.message.textContent = message;
                }
            }
            
            async trackTask(taskId, title = 'Processing...') {
                this.taskId = taskId;
                this.show(title);
                
                // Poll progress endpoint
                this.pollInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`/api/progress/${taskId}`);
                        const data = await response.json();
                        
                        this.updateProgress(data.progress || 0, data.message || '');
                        
                        if (data.status === 'completed') {
                            this.updateProgress(100, 'Completed successfully!');
                            setTimeout(() => {
                                this.hide();
                                showAlert('Operation completed successfully!', 'success');
                                // Reload page to show updated data
                                window.location.reload();
                            }, 1500);
                        } else if (data.status === 'error') {
                            this.hide();
                            showAlert('Error: ' + data.message, 'error');
                        }
                    } catch (error) {
                        console.error('Progress polling error:', error);
                        this.hide();
                        showAlert('Failed to track progress: ' + error.message, 'error');
                    }
                }, 1000); // Poll every second
            }
        }
        
        // Global progress tracker instance
        const progressTracker = new ProgressTracker();
    </script>
    
    {% block extra_js %}{% endblock %}
</body>
</html>
